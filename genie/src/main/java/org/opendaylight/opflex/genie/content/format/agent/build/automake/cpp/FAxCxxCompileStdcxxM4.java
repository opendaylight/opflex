package org.opendaylight.opflex.genie.content.format.agent.build.automake.cpp;

import org.opendaylight.opflex.genie.engine.file.WriteStats;
import org.opendaylight.opflex.genie.engine.format.*;

/**
 * Created by readams on 10/26/16.
 */
public class FAxCxxCompileStdcxxM4
        extends GenericFormatterTask
{
    public FAxCxxCompileStdcxxM4(
            FormatterCtx aInFormatterCtx,
            FileNameRule aInFileNameRule,
            Indenter aInIndenter,
            BlockFormatDirective aInHeaderFormatDirective,
            BlockFormatDirective aInCommentFormatDirective,
            boolean aInIsUserFile,
            WriteStats aInStats)
    {
        super(aInFormatterCtx,
              aInFileNameRule,
              aInIndenter,
              aInHeaderFormatDirective,
              aInCommentFormatDirective,
              aInIsUserFile,
              aInStats);
    }

    public void generate()
    {
        out.println(FORMAT);
    }

    public static final String FORMAT =
        "# ===========================================================================\n"
        + "#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html\n"
        + "# ===========================================================================\n"
        + "#\n"
        + "# SYNOPSIS\n"
        + "#\n"
        + "#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])\n"
        + "#\n"
        + "# DESCRIPTION\n"
        + "#\n"
        + "#   Check for baseline language coverage in the compiler for the specified\n"
        + "#   version of the C++ standard.  If necessary, add switches to CXX and\n"
        + "#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)\n"
        + "#   or '14' (for the C++14 standard).\n"
        + "#\n"
        + "#   The second argument, if specified, indicates whether you insist on an\n"
        + "#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.\n"
        + "#   -std=c++11).  If neither is specified, you get whatever works, with\n"
        + "#   preference for an extended mode.\n"
        + "#\n"
        + "#   The third argument, if specified 'mandatory' or if left unspecified,\n"
        + "#   indicates that baseline support for the specified C++ standard is\n"
        + "#   required and that the macro should error out if no mode with that\n"
        + "#   support is found.  If specified 'optional', then configuration proceeds\n"
        + "#   regardless, after defining HAVE_CXX${VERSION} if and only if a\n"
        + "#   supporting mode is found.\n"
        + "#\n"
        + "# LICENSE\n"
        + "#\n"
        + "#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>\n"
        + "#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>\n"
        + "#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>\n"
        + "#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>\n"
        + "#   Copyright (c) 2015 Paul Norman <penorman@mac.com>\n"
        + "#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>\n"
        + "#\n"
        + "#   Copying and distribution of this file, with or without modification, are\n"
        + "#   permitted in any medium without royalty provided the copyright notice\n"
        + "#   and this notice are preserved.  This file is offered as-is, without any\n"
        + "#   warranty.\n"
        + "\n"
        + "#serial 4\n"
        + "\n"
        + "dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro\n"
        + "dnl  (serial version number 13).\n"
        + "\n"
        + "AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n"
        + "  m4_if([$1], [11], [],\n"
        + "        [$1], [14], [],\n"
        + "        [$1], [17], [m4_fatal([support for C++17 not yet implemented in AX_CXX_COMPILE_STDCXX])],\n"
        + "        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl\n"
        + "  m4_if([$2], [], [],\n"
        + "        [$2], [ext], [],\n"
        + "        [$2], [noext], [],\n"
        + "        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl\n"
        + "  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],\n"
        + "        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],\n"
        + "        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],\n"
        + "        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])\n"
        + "  AC_LANG_PUSH([C++])dnl\n"
        + "  ac_success=no\n"
        + "  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,\n"
        + "  ax_cv_cxx_compile_cxx$1,\n"
        + "  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n"
        + "    [ax_cv_cxx_compile_cxx$1=yes],\n"
        + "    [ax_cv_cxx_compile_cxx$1=no])])\n"
        + "  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then\n"
        + "    ac_success=yes\n"
        + "  fi\n"
        + "\n"
        + "  m4_if([$2], [noext], [], [dnl\n"
        + "  if test x$ac_success = xno; then\n"
        + "    for switch in -std=gnu++$1 -std=gnu++0x; do\n"
        + "      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n"
        + "      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n"
        + "                     $cachevar,\n"
        + "        [ac_save_CXX=\"$CXX\"\n"
        + "         CXX=\"$CXX $switch\"\n"
        + "         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n"
        + "          [eval $cachevar=yes],\n"
        + "          [eval $cachevar=no])\n"
        + "         CXX=\"$ac_save_CXX\"])\n"
        + "      if eval test x\\$$cachevar = xyes; then\n"
        + "        CXX=\"$CXX $switch\"\n"
        + "        if test -n \"$CXXCPP\" ; then\n"
        + "          CXXCPP=\"$CXXCPP $switch\"\n"
        + "        fi\n"
        + "        ac_success=yes\n"
        + "        break\n"
        + "      fi\n"
        + "    done\n"
        + "  fi])\n"
        + "\n"
        + "  m4_if([$2], [ext], [], [dnl\n"
        + "  if test x$ac_success = xno; then\n"
        + "    dnl HP's aCC needs +std=c++11 according to:\n"
        + "    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf\n"
        + "    dnl Cray's crayCC needs \"-h std=c++11\"\n"
        + "    for switch in -std=c++$1 -std=c++0x +std=c++$1 \"-h std=c++$1\"; do\n"
        + "      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n"
        + "      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n"
        + "                     $cachevar,\n"
        + "        [ac_save_CXX=\"$CXX\"\n"
        + "         CXX=\"$CXX $switch\"\n"
        + "         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n"
        + "          [eval $cachevar=yes],\n"
        + "          [eval $cachevar=no])\n"
        + "         CXX=\"$ac_save_CXX\"])\n"
        + "      if eval test x\\$$cachevar = xyes; then\n"
        + "        CXX=\"$CXX $switch\"\n"
        + "        if test -n \"$CXXCPP\" ; then\n"
        + "          CXXCPP=\"$CXXCPP $switch\"\n"
        + "        fi\n"
        + "        ac_success=yes\n"
        + "        break\n"
        + "      fi\n"
        + "    done\n"
        + "  fi])\n"
        + "  AC_LANG_POP([C++])\n"
        + "  if test x$ax_cxx_compile_cxx$1_required = xtrue; then\n"
        + "    if test x$ac_success = xno; then\n"
        + "      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])\n"
        + "    fi\n"
        + "  fi\n"
        + "  if test x$ac_success = xno; then\n"
        + "    HAVE_CXX$1=0\n"
        + "    AC_MSG_NOTICE([No compiler with C++$1 support was found])\n"
        + "  else\n"
        + "    HAVE_CXX$1=1\n"
        + "    AC_DEFINE(HAVE_CXX$1,1,\n"
        + "              [define if the compiler supports basic C++$1 syntax])\n"
        + "  fi\n"
        + "  AC_SUBST(HAVE_CXX$1)\n"
        + "])\n"
        + "\n"
        + "\n"
        + "dnl  Test body for checking C++11 support\n"
        + "\n"
        + "m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],\n"
        + "  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n"
        + ")\n"
        + "\n"
        + "\n"
        + "dnl  Test body for checking C++14 support\n"
        + "\n"
        + "m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],\n"
        + "  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n"
        + "  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14\n"
        + ")\n"
        + "\n"
        + "\n"
        + "dnl  Tests for new features in C++11\n"
        + "\n"
        + "m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[\n"
        + "\n"
        + "// If the compiler admits that it is not ready for C++11, why torture it?\n"
        + "// Hopefully, this will speed up the test.\n"
        + "\n"
        + "#ifndef __cplusplus\n"
        + "\n"
        + "#error \"This is not a C++ compiler\"\n"
        + "\n"
        + "#elif __cplusplus < 201103L\n"
        + "\n"
        + "#error \"This is not a C++11 compiler\"\n"
        + "\n"
        + "#else\n"
        + "\n"
        + "namespace cxx11\n"
        + "{\n"
        + "\n"
        + "  namespace test_static_assert\n"
        + "  {\n"
        + "\n"
        + "    template <typename T>\n"
        + "    struct check\n"
        + "    {\n"
        + "      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n"
        + "    };\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_final_override\n"
        + "  {\n"
        + "\n"
        + "    struct Base\n"
        + "    {\n"
        + "      virtual void f() {}\n"
        + "    };\n"
        + "\n"
        + "    struct Derived : public Base\n"
        + "    {\n"
        + "      virtual void f() override {}\n"
        + "    };\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_double_right_angle_brackets\n"
        + "  {\n"
        + "\n"
        + "    template < typename T >\n"
        + "    struct check {};\n"
        + "\n"
        + "    typedef check<void> single_type;\n"
        + "    typedef check<check<void>> double_type;\n"
        + "    typedef check<check<check<void>>> triple_type;\n"
        + "    typedef check<check<check<check<void>>>> quadruple_type;\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_decltype\n"
        + "  {\n"
        + "\n"
        + "    int\n"
        + "    f()\n"
        + "    {\n"
        + "      int a = 1;\n"
        + "      decltype(a) b = 2;\n"
        + "      return a + b;\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_type_deduction\n"
        + "  {\n"
        + "\n"
        + "    template < typename T1, typename T2 >\n"
        + "    struct is_same\n"
        + "    {\n"
        + "      static const bool value = false;\n"
        + "    };\n"
        + "\n"
        + "    template < typename T >\n"
        + "    struct is_same<T, T>\n"
        + "    {\n"
        + "      static const bool value = true;\n"
        + "    };\n"
        + "\n"
        + "    template < typename T1, typename T2 >\n"
        + "    auto\n"
        + "    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n"
        + "    {\n"
        + "      return a1 + a2;\n"
        + "    }\n"
        + "\n"
        + "    int\n"
        + "    test(const int c, volatile int v)\n"
        + "    {\n"
        + "      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n"
        + "      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n"
        + "      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n"
        + "      auto ac = c;\n"
        + "      auto av = v;\n"
        + "      auto sumi = ac + av + 'x';\n"
        + "      auto sumf = ac + av + 1.0;\n"
        + "      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n"
        + "      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n"
        + "      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n"
        + "      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n"
        + "      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n"
        + "      return (sumf > 0.0) ? sumi : add(c, v);\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_noexcept\n"
        + "  {\n"
        + "\n"
        + "    int f() { return 0; }\n"
        + "    int g() noexcept { return 0; }\n"
        + "\n"
        + "    static_assert(noexcept(f()) == false, \"\");\n"
        + "    static_assert(noexcept(g()) == true, \"\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_constexpr\n"
        + "  {\n"
        + "\n"
        + "    template < typename CharT >\n"
        + "    unsigned long constexpr\n"
        + "    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n"
        + "    {\n"
        + "      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n"
        + "    }\n"
        + "\n"
        + "    template < typename CharT >\n"
        + "    unsigned long constexpr\n"
        + "    strlen_c(const CharT *const s) noexcept\n"
        + "    {\n"
        + "      return strlen_c_r(s, 0UL);\n"
        + "    }\n"
        + "\n"
        + "    static_assert(strlen_c(\"\") == 0UL, \"\");\n"
        + "    static_assert(strlen_c(\"1\") == 1UL, \"\");\n"
        + "    static_assert(strlen_c(\"example\") == 7UL, \"\");\n"
        + "    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_rvalue_references\n"
        + "  {\n"
        + "\n"
        + "    template < int N >\n"
        + "    struct answer\n"
        + "    {\n"
        + "      static constexpr int value = N;\n"
        + "    };\n"
        + "\n"
        + "    answer<1> f(int&)       { return answer<1>(); }\n"
        + "    answer<2> f(const int&) { return answer<2>(); }\n"
        + "    answer<3> f(int&&)      { return answer<3>(); }\n"
        + "\n"
        + "    void\n"
        + "    test()\n"
        + "    {\n"
        + "      int i = 0;\n"
        + "      const int c = 0;\n"
        + "      static_assert(decltype(f(i))::value == 1, \"\");\n"
        + "      static_assert(decltype(f(c))::value == 2, \"\");\n"
        + "      static_assert(decltype(f(0))::value == 3, \"\");\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_uniform_initialization\n"
        + "  {\n"
        + "\n"
        + "    struct test\n"
        + "    {\n"
        + "      static const int zero {};\n"
        + "      static const int one {1};\n"
        + "    };\n"
        + "\n"
        + "    static_assert(test::zero == 0, \"\");\n"
        + "    static_assert(test::one == 1, \"\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_lambdas\n"
        + "  {\n"
        + "\n"
        + "    void\n"
        + "    test1()\n"
        + "    {\n"
        + "      auto lambda1 = [](){};\n"
        + "      auto lambda2 = lambda1;\n"
        + "      lambda1();\n"
        + "      lambda2();\n"
        + "    }\n"
        + "\n"
        + "    int\n"
        + "    test2()\n"
        + "    {\n"
        + "      auto a = [](int i, int j){ return i + j; }(1, 2);\n"
        + "      auto b = []() -> int { return '0'; }();\n"
        + "      auto c = [=](){ return a + b; }();\n"
        + "      auto d = [&](){ return c; }();\n"
        + "      auto e = [a, &b](int x) mutable {\n"
        + "        const auto identity = [](int y){ return y; };\n"
        + "        for (auto i = 0; i < a; ++i)\n"
        + "          a += b--;\n"
        + "        return x + identity(a + b);\n"
        + "      }(0);\n"
        + "      return a + b + c + d + e;\n"
        + "    }\n"
        + "\n"
        + "    int\n"
        + "    test3()\n"
        + "    {\n"
        + "      const auto nullary = [](){ return 0; };\n"
        + "      const auto unary = [](int x){ return x; };\n"
        + "      using nullary_t = decltype(nullary);\n"
        + "      using unary_t = decltype(unary);\n"
        + "      const auto higher1st = [](nullary_t f){ return f(); };\n"
        + "      const auto higher2nd = [unary](nullary_t f1){\n"
        + "        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n"
        + "      };\n"
        + "      return higher1st(nullary) + higher2nd(nullary)(unary);\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_variadic_templates\n"
        + "  {\n"
        + "\n"
        + "    template <int...>\n"
        + "    struct sum;\n"
        + "\n"
        + "    template <int N0, int... N1toN>\n"
        + "    struct sum<N0, N1toN...>\n"
        + "    {\n"
        + "      static constexpr auto value = N0 + sum<N1toN...>::value;\n"
        + "    };\n"
        + "\n"
        + "    template <>\n"
        + "    struct sum<>\n"
        + "    {\n"
        + "      static constexpr auto value = 0;\n"
        + "    };\n"
        + "\n"
        + "    static_assert(sum<>::value == 0, \"\");\n"
        + "    static_assert(sum<1>::value == 1, \"\");\n"
        + "    static_assert(sum<23>::value == 23, \"\");\n"
        + "    static_assert(sum<1, 2>::value == 3, \"\");\n"
        + "    static_assert(sum<5, 5, 11>::value == 21, \"\");\n"
        + "    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n"
        + "  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n"
        + "  // because of this.\n"
        + "  namespace test_template_alias_sfinae\n"
        + "  {\n"
        + "\n"
        + "    struct foo {};\n"
        + "\n"
        + "    template<typename T>\n"
        + "    using member = typename T::member_type;\n"
        + "\n"
        + "    template<typename T>\n"
        + "    void func(...) {}\n"
        + "\n"
        + "    template<typename T>\n"
        + "    void func(member<T>*) {}\n"
        + "\n"
        + "    void test();\n"
        + "\n"
        + "    void test() { func<foo>(0); }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "}  // namespace cxx11\n"
        + "\n"
        + "#endif  // __cplusplus >= 201103L\n"
        + "\n"
        + "]])\n"
        + "\n"
        + "\n"
        + "dnl  Tests for new features in C++14\n"
        + "\n"
        + "m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[\n"
        + "\n"
        + "// If the compiler admits that it is not ready for C++14, why torture it?\n"
        + "// Hopefully, this will speed up the test.\n"
        + "\n"
        + "#ifndef __cplusplus\n"
        + "\n"
        + "#error \"This is not a C++ compiler\"\n"
        + "\n"
        + "#elif __cplusplus < 201402L\n"
        + "\n"
        + "#error \"This is not a C++14 compiler\"\n"
        + "\n"
        + "#else\n"
        + "\n"
        + "namespace cxx14\n"
        + "{\n"
        + "\n"
        + "  namespace test_polymorphic_lambdas\n"
        + "  {\n"
        + "\n"
        + "    int\n"
        + "    test()\n"
        + "    {\n"
        + "      const auto lambda = [](auto&&... args){\n"
        + "        const auto istiny = [](auto x){\n"
        + "          return (sizeof(x) == 1UL) ? 1 : 0;\n"
        + "        };\n"
        + "        const int aretiny[] = { istiny(args)... };\n"
        + "        return aretiny[0];\n"
        + "      };\n"
        + "      return lambda(1, 1L, 1.0f, '1');\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_binary_literals\n"
        + "  {\n"
        + "\n"
        + "    constexpr auto ivii = 0b0000000000101010;\n"
        + "    static_assert(ivii == 42, \"wrong value\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_generalized_constexpr\n"
        + "  {\n"
        + "\n"
        + "    template < typename CharT >\n"
        + "    constexpr unsigned long\n"
        + "    strlen_c(const CharT *const s) noexcept\n"
        + "    {\n"
        + "      auto length = 0UL;\n"
        + "      for (auto p = s; *p; ++p)\n"
        + "        ++length;\n"
        + "      return length;\n"
        + "    }\n"
        + "\n"
        + "    static_assert(strlen_c(\"\") == 0UL, \"\");\n"
        + "    static_assert(strlen_c(\"x\") == 1UL, \"\");\n"
        + "    static_assert(strlen_c(\"test\") == 4UL, \"\");\n"
        + "    static_assert(strlen_c(\"another\\0test\") == 7UL, \"\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_lambda_init_capture\n"
        + "  {\n"
        + "\n"
        + "    int\n"
        + "    test()\n"
        + "    {\n"
        + "      auto x = 0;\n"
        + "      const auto lambda1 = [a = x](int b){ return a + b; };\n"
        + "      const auto lambda2 = [a = lambda1(x)](){ return a; };\n"
        + "      return lambda2();\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_digit_seperators\n"
        + "  {\n"
        + "\n"
        + "    constexpr auto ten_million = 100'000'000;\n"
        + "    static_assert(ten_million == 100000000, \"\");\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "  namespace test_return_type_deduction\n"
        + "  {\n"
        + "\n"
        + "    auto f(int& x) { return x; }\n"
        + "    decltype(auto) g(int& x) { return x; }\n"
        + "\n"
        + "    template < typename T1, typename T2 >\n"
        + "    struct is_same\n"
        + "    {\n"
        + "      static constexpr auto value = false;\n"
        + "    };\n"
        + "\n"
        + "    template < typename T >\n"
        + "    struct is_same<T, T>\n"
        + "    {\n"
        + "      static constexpr auto value = true;\n"
        + "    };\n"
        + "\n"
        + "    int\n"
        + "    test()\n"
        + "    {\n"
        + "      auto x = 0;\n"
        + "      static_assert(is_same<int, decltype(f(x))>::value, \"\");\n"
        + "      static_assert(is_same<int&, decltype(g(x))>::value, \"\");\n"
        + "      return x;\n"
        + "    }\n"
        + "\n"
        + "  }\n"
        + "\n"
        + "}  // namespace cxx14\n"
        + "\n"
        + "#endif  // __cplusplus >= 201402L\n"
        + "\n"
        + "]])\n";

}
