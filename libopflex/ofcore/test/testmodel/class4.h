/* -*- C++ -*-; c-basic-offset: 4; indent-tabs-mode: nil */
/*
 * class4 from testmodel
 *
 * Copyright (c) 2014 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

#ifndef TESTMODEL_CLASS4_H
#define TESTMODEL_CLASS4_H

#include <boost/optional.hpp>

#include "opflex/modb/URIBuilder.h"
#include "opflex/modb/mo-internal/MO.h"

namespace testmodel {

/**
 * @brief This is a sample class used in a test model
 *
 * This is the extended documentation for class4
 */
class class4 : public opflex::modb::mointernal::MO {
public:
    /**
     * The unique class ID for class4
     */
    static const opflex::modb::class_id_t CLASS_ID = 4;

    /**
     * Check whether prop9 has been set.  Prop9 is a string scalar
     * property.
     *
     * Prop9 documentation would go here.
     *
     * @return true if prop9 has been set
     */
    bool isProp9Set() {
        return getObjectInstance().isSet(9, opflex::modb::PropertyInfo::STRING);
    }

    /**
     * Get the value of prop9 if it has been set.  Prop9 is a string
     * scalar property.
     *
     * Prop9 documentation would go here.
     *
     * @return the value of prop9, or boost::none if it is not set.
     */
    boost::optional<const std::string&> getProp9() {
        if (isProp9Set())
            return getObjectInstance().getString(9);
        return boost::none;
    }

    /**
     * Get the value of prop9 if it has been set, or the specified
     * default value of prop9 has not been set.  Prop9 is a string
     * scalar property.
     *
     * Prop9 documentation would go here.
     *
     * @param defaultValue the default value to return of prop9 is not set.
     * @return the value of prop9 or defaultValue
     */
    const std::string& getProp9(const std::string& defaultValue) {
        return getProp9().get_value_or(defaultValue);
    }

    /**
     * Set prop9 to the specified value in the currently-active
     * mutator.  
     * 
     * @param newValue the new value to set.
     * @return a reference to the current object
     * @throws std::logic_error if no mutator is active
     * @see opflex::modb::Mutator
     */
    class4& setProp9(const std::string&  newValue) {
        getTLMutator().modify(CLASS_ID, getURI())->setString(9, newValue);
        return *this;
    }

    /**
     * Unset prop9 in the currently-active mutator
     *
     * @return a reference to the current object
     * @throws std::logic_error if no mutator is active
     * @see opflex::modb::Mutator
     */
    class4& unsetProp9() {
        getTLMutator().modify(CLASS_ID, getURI())
            ->unset(9,
                    opflex::modb::PropertyInfo::STRING,
                    opflex::modb::PropertyInfo::SCALAR);
        return *this;
    }

    /**
     * Retrieve an instance of class4 from the managed object store.
     * If the object does not exist in the local store, returns
     * boost::none.  Note that even though it may not exist locally,
     * it may still exist remotely.
     * 
     * @param framework the framework instance to use
     * @param uri the URI of the object to retrieve
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class4> > 
    resolve(opflex::ofcore::OFFramework& framework, 
            const opflex::modb::URI& uri) {
        return opflex::modb::mointernal
            ::MO::resolve<class4>(framework, CLASS_ID, uri);
    }

    /**
     * Retrieve an instance of class4 from the managed object store
     * using the default framework instance.  If the object does not
     * exist in the local store, returns boost::none.  Note that even
     * though it may not exist locally, it may still exist in
     * remotely.
     * 
     * @param uri the URI of the object to retrieve
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class4> > 
    resolve(const opflex::modb::URI& uri) { 
        return resolve(opflex::ofcore::OFFramework::defaultInstance(),
                       uri);
    }

    /**
     * Retrieve an instance of class4 from the managed object store by
     * constructing its URI from the path elements that lead to it.
     * If the object does not exist in the local store, returns
     * boost::none.  Note that even though it may not exist locally,
     * it may still exist remotely.
     *
     * The object URI generated by this function will take the form:
     * /class4/[prop9Value]
     * 
     * @param framework the framework instance to use
     * @param prop9Value The value of prop9, a naming property for class4
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class4> > 
    resolve(opflex::ofcore::OFFramework& framework,
            const std::string& prop9Value) {
        return resolve(framework, 
                       opflex::modb::URIBuilder()
                           .addElement("class4")
                           .addElement(prop9Value)
                           .build());
    }

    /**
     * Retrieve an instance of class4 from the default managed object
     * store by constructing its URI from the path elements that lead
     * to it.  If the object does not exist in the local store,
     * returns boost::none.  Note that even though it may not exist
     * locally, it may still exist remotely.
     *
     * The object URI generated by this function will take the form:
     * /class4/[prop9Value]
     * 
     * @param prop9Value The value of prop9, a naming property for class4
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class4> > 
    resolve(const std::string& prop9Value) { 
        return resolve(opflex::ofcore::OFFramework::defaultInstance(),
                       prop9Value);
    }

    /**
     * Register a listener that will get called for changes related to
     * this class.  This listener will be called for any modifications
     * of this class or any transitive children of this class.
     *
     * @param framework the framework instance 
     * @param listener the listener functional object that should be
     * called when changes occur related to the class.  This memory is
     * owned by the caller and should be freed only after it has been
     * unregistered.
     */
    static void registerListener(opflex::ofcore::OFFramework& framework,
                                 opflex::modb::ObjectListener* listener) {
        return opflex::modb::mointernal
            ::MO::registerListener(framework, listener, CLASS_ID);
    }

    /**
     * Register a listener that will get called for changes related to
     * this class with the default framework instance.  This listener
     * will be called for any modifications of this class or any
     * transitive children of this class.
     *
     * @param listener the listener functional object that should be
     * called when changes occur related to the class.  This memory is
     * owned by the caller and should be freed only after it has been
     * unregistered.
     */
    static void registerListener(opflex::modb::ObjectListener* listener) {
        registerListener(opflex::ofcore::OFFramework::defaultInstance(),
                         listener);
    }

    /**
     * Unregister a listener from updates to this class.
     *
     * @param framework the framework instance 
     * @param listener The listener to unregister.
     */
    static void unregisterListener(opflex::ofcore::OFFramework& framework,
                                   opflex::modb::ObjectListener* listener) {
        return opflex::modb::mointernal
            ::MO::unregisterListener(framework, listener, CLASS_ID);
    }

    /**
     * Unregister a listener from updates to this class from the
     * default framework instance.
     *
     * @param listener The listener to unregister.
     */
    static void unregisterListener(opflex::modb::ObjectListener* listener) {
        unregisterListener(opflex::ofcore::OFFramework::defaultInstance(),
                           listener);
    }

    /**
     * Remove this instance using the currently-active mutator.  If
     * the object does not exist, then this will be a no-op.  If this
     * object has any children, they will be garbage-collected at some
     * future time.
     * @throws std::logic_error if no mutator is active
     */
    void remove() {
        getTLMutator().remove(CLASS_ID, getURI());
    }

    /**
     * Remove the class4 object with the specified URI using the
     * currently-active mutator.  If the object does not exist, then
     * this will be a no-op.  If this object has any children, they
     * will be garbage-collected at some future time.
     *
     * @param uri the URI of the object to remove
     * @throws std::logic_error if no mutator is active
     */
    static void remove(opflex::ofcore::OFFramework& framework,
                       const opflex::modb::URI& uri) {
        MO::remove(framework, CLASS_ID, uri);
    }

    /**
     * Remove the class4 object with the specified URI using the
     * currently-active mutator in the default framework.  If the
     * object does not exist, then this will be a no-op.  If this
     * object has any children, they will be garbage-collected at some
     * future time.
     *
     * @param uri the URI of the object to remove
     * @throws std::logic_error if no mutator is active
     */
    static void remove(const opflex::modb::URI& uri) {
        remove(opflex::ofcore::OFFramework::defaultInstance(), uri);
    }

    /**
     * Remove the class4 object with the specified path elements from
     * the managed object store.  If the object does not exist, then
     * this will be a no-op.  If this object has any children, they
     * will be garbage-collected at some future time.
     *
     * The object URI generated by this function will take the form:
     * /class4/[prop9Value]
     * 
     * @param framework the framework instance to use
     * @param prop9Value The value of prop9, a naming property for class4
     * @throws std::logic_error if no mutator is active
     */
    static void remove(opflex::ofcore::OFFramework& framework,
                       const std::string& prop9Value) {
        MO::remove(framework, CLASS_ID,
                   opflex::modb::URIBuilder()
                       .addElement("class4")
                       .addElement(prop9Value)
                       .build());
    }

    /**
     * Remove the class4 object with the specified path elements from
     * the managed object store using the default framework instance.
     * If the object does not exist, then this will be a no-op.  If
     * this object has any children, they will be garbage-collected at
     * some future time.
     *
     * The object URI generated by this function will take the form:
     * /class4/[prop9Value]
     * 
     * @param framework the framework instance to use
     * @param prop9Value The value of prop9, a naming property for class4
     * @throws std::logic_error if no mutator is active
     */
    static void remove(const std::string& prop9Value) {
        remove(opflex::ofcore::OFFramework::defaultInstance(),
               prop9Value);
    }

    /**
     * Construct a class4 wrapper class.  This should typically not be
     * called from user code.
     */
    class4(opflex::ofcore::OFFramework& framework,
           const opflex::modb::URI& uri, 
           const boost::shared_ptr<const opflex::modb
              ::mointernal::ObjectInstance>& oi)
        : MO(framework, CLASS_ID, uri, oi) { }
};

} /* namespace testmodel */

#endif /* TESTMODEL_CLASS4_H */
