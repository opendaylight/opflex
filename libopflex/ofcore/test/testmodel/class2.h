/* -*- C++ -*-; c-basic-offset: 4; indent-tabs-mode: nil */
/*
 * class2 from testmodel
 *
 * Copyright (c) 2014 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

#ifndef TESTMODEL_CLASS2_H
#define TESTMODEL_CLASS2_H

#include <boost/optional.hpp>

#include "opflex/modb/URIBuilder.h"
#include "opflex/modb/mo-internal/MO.h"

#include "testmodel/class3.h"

namespace testmodel {

/**
 * @brief This is a sample class used in a test model
 *
 * This is the extended documentation for class2
 */
class class2 : public opflex::modb::mointernal::MO {
public:
    /**
     * The unique class ID for class2
     */
    static const opflex::modb::class_id_t CLASS_ID = 2;

    /**
     * Check whether prop4 has been set.  Prop4 is a signed 64-bit
     * integer scalar property.
     *
     * Prop4 documentation would go here.
     *
     * @return true if prop4 has been set
     */
    bool isProp4Set() {
        return getObjectInstance().isSet(4, opflex::modb::PropertyInfo::S64);
    }

    /**
     * Get the value of prop4 if it has been set.  Prop4 is an
     * unsigned 64-bit integer scalar property.
     *
     * Prop4 documentation would go here.
     *
     * @return the value of prop4, or boost::none if it is not set.
     */
    boost::optional<int64_t> getProp4() {
        if (isProp4Set())
            return getObjectInstance().getInt64(4);
        return boost::none;
    }

    /**
     * Get the value of prop4 if it has been set, or the specified
     * default value of prop4 has not been set.  Prop4 is a signed
     * 64-bit integer scalar property.
     *
     * Prop4 documentation would go here.
     *
     * @param defaultValue the default value to return of prop4 is not set.
     * @return the value of prop4 or defaultValue
     */
    int64_t getProp4(int64_t defaultValue) {
        return getProp4().get_value_or(defaultValue);
    }

    /**
     * Set prop4 to the specified value in the currently-active
     * mutator.  
     * 
     * @param newValue the new value to set.
     * @return a reference to the current object
     * @throws std::logic_error if no mutator is active
     * @see opflex::modb::Mutator
     */
    class2& setProp4(int64_t newValue) {
        getTLMutator().modify(CLASS_ID, getURI())->setInt64(4, newValue);
        return *this;
    }

    /**
     * Unset prop4 in the currently-active mutator
     *
     * @throws std::logic_error if no mutator is active
     * @return a reference to the current object
     * @see opflex::modb::Mutator
     */
    class2& unsetProp4() {
        getTLMutator().modify(CLASS_ID, getURI())
            ->unset(4,
                    opflex::modb::PropertyInfo::S64,
                    opflex::modb::PropertyInfo::SCALAR);
        return *this;
    }

    /**
     * Retrieve an instance of class2 from the managed object store.
     * If the object does not exist in the local store, returns
     * boost::none.  Note that even though it may not exist locally,
     * it may still exist remotely.
     * 
     * @param framework the framework instance to use
     * @param uri the URI of the object to retrieve
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class2> > 
    resolve(opflex::ofcore::OFFramework& framework, 
            const opflex::modb::URI& uri) {
        return opflex::modb::mointernal
            ::MO::resolve<class2>(framework, CLASS_ID, uri);
    }

    /**
     * Retrieve an instance of class2 from the managed object store
     * using the default framework instance.  If the object does not
     * exist in the local store, returns boost::none.  Note that even
     * though it may not exist locally, it may still exist in
     * remotely.
     * 
     * @param uri the URI of the object to retrieve
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class2> > 
    resolve(const opflex::modb::URI& uri) { 
        return resolve(opflex::ofcore::OFFramework::defaultInstance(),
                       uri);
    }

    /**
     * Retrieve an instance of class2 from the managed object store by
     * constructing its URI from the path elements that lead to it.
     * If the object does not exist in the local store, returns
     * boost::none.  Note that even though it may not exist locally,
     * it may still exist remotely.
     *
     * The object URI generated by this function will take the form:
     * /class2/[prop4Value]
     * 
     * @param framework the framework instance to use
     * @param prop4Value The value of prop4, a naming property for class2 
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class2> > 
    resolve(opflex::ofcore::OFFramework& framework,
            int64_t prop4Value) {
        return resolve(framework, 
                       opflex::modb::URIBuilder()
                           .addElement("class2")
                           .addElement(prop4Value)
                           .build());
    }

    /**
     * Retrieve an instance of class2 from the default managed object
     * store by constructing its URI from the path elements that lead
     * to it.  If the object does not exist in the local store,
     * returns boost::none.  Note that even though it may not exist
     * locally, it may still exist remotely.
     *
     * The object URI generated by this function will take the form:
     * /class2/[prop4Value]
     * 
     * @param prop4Value The value of prop4, a naming property for class2 
     * @return a shared pointer to the object or boost::none if it
     * does not exist.
     */
    static boost::optional<boost::shared_ptr<class2> > 
    resolve(int64_t prop4Value) { 
        return resolve(opflex::ofcore::OFFramework::defaultInstance(),
                       prop4Value);
    }

    /**
     * Retrieve the child object with the specified naming
     * properties. If the object does not exist in the local store,
     * returns boost::none.  Note that even though it may not exist
     * locally, it may still exist remotely.
     *
     * @param prop6Value The value of prop6, a naming property for class3
     * @param prop7Value The value of prop7, a naming property for class3
     */
    boost::optional<boost::shared_ptr<class3> > 
    resolveClass3(int64_t prop6Value,
                  const std::string& prop7Value) {
        return class3::resolve(getFramework(), 
                               opflex::modb::URIBuilder(getURI())
                                   .addElement("class3")
                                   .addElement(prop6Value)
                                   .addElement(prop7Value)
                                   .build());
    }

    /**
     * Resolve and retrieve all of the immediate children of type
     * class3. Note that this retrieves only those children that
     * exist in the local store.  It is possible that are other
     * children exist remotely.
     *
     * The resulting managed objects will be added to the result
     * vector provided.
     * 
     * @param out a reference to a vector that will receive the child
     * objects.
     */
    void resolveClass3(/* out */ std::vector<boost::shared_ptr<class3> >& out) {
        return opflex::modb::mointernal
            ::MO::resolveChildren<class3>(getFramework(),
                                          CLASS_ID, getURI(),
                                          5, 3,
                                          out);
    }

    /**
     * Create a new child object with the specified naming properties
     * and make it a child of this object in the currently-active
     * mutator.  If the object already exists in the store, get a
     * mutable copy of that object.  If the object already exists, get
     * a mutable copy of that object.
     *
     * @param prop6Value The value of prop6, a naming property for class3
     * @param prop7Value The value of prop7, a naming property for class3
     * @throws std::logic_error if no mutator is active
     * @return a shared pointer to the (possibly new) object
     */
    boost::shared_ptr<class3> addClass3(int64_t prop6Value,
                                        const std::string& prop7Value) {
        boost::shared_ptr<class3> result = 
            addChild<class3>(CLASS_ID, getURI(), 5, 3,
                             opflex::modb::URIBuilder(getURI())
                                 .addElement("class3")
                                 .addElement(prop6Value)
                                 .addElement(prop7Value)
                                 .build());
        result->setProp6(prop6Value);
        result->setProp7(prop7Value);
        return result;
    }

    /**
     * Register a listener that will get called for changes related to
     * this class.  This listener will be called for any modifications
     * of this class or any transitive children of this class.
     *
     * @param framework the framework instance 
     * @param listener the listener functional object that should be
     * called when changes occur related to the class.  This memory is
     * owned by the caller and should be freed only after it has been
     * unregistered.
     */
    static void registerListener(opflex::ofcore::OFFramework& framework,
                                 opflex::modb::ObjectListener* listener) {
        return opflex::modb::mointernal
            ::MO::registerListener(framework, listener, CLASS_ID);
    }

    /**
     * Register a listener that will get called for changes related to
     * this class with the default framework instance.  This listener
     * will be called for any modifications of this class or any
     * transitive children of this class.
     *
     * @param listener the listener functional object that should be
     * called when changes occur related to the class.  This memory is
     * owned by the caller and should be freed only after it has been
     * unregistered.
     */
    static void registerListener(opflex::modb::ObjectListener* listener) {
        registerListener(opflex::ofcore::OFFramework::defaultInstance(),
                         listener);
    }

    /**
     * Unregister a listener from updates to this class.
     *
     * @param framework the framework instance 
     * @param listener The listener to unregister.
     */
    static void unregisterListener(opflex::ofcore::OFFramework& framework,
                                   opflex::modb::ObjectListener* listener) {
        return opflex::modb::mointernal
            ::MO::unregisterListener(framework, listener, CLASS_ID);
    }

    /**
     * Unregister a listener from updates to this class from the
     * default framework instance.
     *
     * @param listener The listener to unregister.
     */
    static void unregisterListener(opflex::modb::ObjectListener* listener) {
        unregisterListener(opflex::ofcore::OFFramework::defaultInstance(),
                           listener);
    }

    /**
     * Construct a class2 wrapper class.  This should typically not be
     * called from user code.
     */
    class2(opflex::ofcore::OFFramework& framework,
           const opflex::modb::URI& uri, 
           const boost::shared_ptr<const opflex::modb
              ::mointernal::ObjectInstance>& oi)
        : MO(framework, CLASS_ID, uri, oi) { }
};

} /* namespace testmodel */

#endif /* TESTMODEL_CLASS2_H */
