/*
 * Copyright (c) 2014 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */


#ifndef _OPFLEX_ENFORCER_INVENTORY_H_
#define _OPFLEX_ENFORCER_INVENTORY_H_

#include <utility>
#include <list>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include <boost/functional/hash.hpp>

#include <internal/modb.h>

namespace opflex {
namespace enforcer {

/**
 * @brief Structure to hold information about change to a MO such
 * as the kind of change as well as the old and new versions of the
 * object.
 */
struct ChangeInfo {
	/** Kind of change */
    enum TYPE {ADD, REMOVE, MOD, NOOP};     // order important for comparison

    ChangeInfo(unsigned long sq) : seqId(sq), changeType(NOOP) {}
    ChangeInfo(unsigned long sq, TYPE c, const modb::MoBasePtr& co,
               const modb::MoBasePtr& oo) :
        seqId(sq), changeType(c), currObject(co), oldObject(oo) {}

    /**
     * Returns URI of the MO that changed
     */
    const modb::URI& GetUri() const {
        return GetObject()->GetUri();
    }

    /**
     * Returns MO-class of the MO that changed
     */
    const modb::class_id_t GetClass() const {
        return GetObject()->GetClass();
    }

    /**
     * Returns the changed MO, or the old object if object was deleted
     */
    const modb::MoBasePtr& GetObject() const {
        return currObject == NULL ? oldObject : currObject;
    }

    unsigned long seqId;		// used for ordering changes
    TYPE changeType;
    modb::MoBasePtr currObject;
    modb::MoBasePtr oldObject;
};

/**
 * Equality operator to use ChangeInfo as key in hash-based lookups
 */
bool operator==(const ChangeInfo& lhs, const ChangeInfo& rhs);

/**
 * Hash value to use ChangeInfo as key in hash-based lookups
 */
size_t hash_value(const ChangeInfo& chgInfo);

/**
 * Less-than operator for sorting on ChangeInfo
 */
bool operator<(const ChangeInfo& lhs, const ChangeInfo& rhs);


typedef std::list<ChangeInfo>            ChangeList;

/**
 * @brief Class that handles update notifications from MODB and manages
 * relationship between managed-objects. Generates additional
 * notifications based on these relations.
 */
class Inventory {
public:
	/**
	 * Constructor that supplies an output list for MO change notifications.
	 * @param cio the list where notifications generated by this class will be enqueued
	 */
    Inventory(ChangeList& cio) : changeInfoOut(cio), changeInfoSeqCounter(0) {}
    ~Inventory() {}

    /**
     * Module start.
     */
    void Start();

    /**
     * Module Stop.
     */
    void Stop();

    /**
     * Handle update notification for MODB.
     * @param cid MO-class of the changed object
     * @uri uri URI of the changed object
     */
    void Update(modb::class_id_t cid, const modb::URI& uri);

    /**
     * Return the MO corresponding to the given URI.
     * @param uri URI to search for
     * @return target MO if found
     */
    modb::MoBasePtr Find(const modb::URI& uri);

    /**
     * Find the network-object of specified type associated with given URI.
     * Traverses the containment hierarchy repeatedly till the target object
     * is found.
     * @param uri URI of network object to start from
     * @param targetClass MO-class of the target object
     * @return target MO if found
     */
    modb::MoBasePtr FindNetObj(const modb::URI& uri, modb::class_id_t targetClass);

private:
    /**
     * Main function for processing update notifications.
     */
    void HandleUpdate();

    typedef std::pair<modb::class_id_t, modb::URI> UpdateInfo;
    typedef std::list<UpdateInfo> UpdateSet;

    UpdateSet updates;		// queue to hold notifications received from MODB

private:

    typedef modb::URI                                        ObjectKey;
    typedef boost::unordered_map<ObjectKey, modb::MoBasePtr> ObjectMap;
    typedef ObjectMap::iterator                              ObjectMapItr;
    typedef boost::unordered_set<ObjectKey>                  ObjectKeySet;

    typedef boost::unordered_map<ObjectKey, ObjectKeySet>    BackLinkMap;

    typedef boost::unordered_set<ChangeInfo>                 ChangeSet;

    /**
     * Convert MODB notification to a ChangeInfo object and update relation
     * maps according to the change in MO state.
     */
    void UpdateRelationMaps(const UpdateInfo& updInfo, ChangeInfo& chgInfo);

    /**
     * Gets the old/new MO corresponding to MODB notifications.
     */
    ChangeInfo::TYPE ResolveUpdate(const UpdateInfo& updInfo,
            ObjectMapItr& oldObj,
            modb::MoBasePtr& newObj);

    /**
     * Updates relation maps in response to a change in end-point object.
     */
    void UpdateEndpointRelations(const ChangeInfo& chgInfo);

    /**
     * Updates relation maps in response to a change in end-point group object.
     */
    void UpdateEndpointGroupRelations(const ChangeInfo& chgInfo);

    /**
     * Updates relation maps in response to a change in network objects.
     */
    void UpdateNetworkDomainRelations(const ChangeInfo& chgInfo);

    /**
     * Updates relation maps in response to a change in policy object.
     */
    void UpdatePolicyRelations(const ChangeInfo& chgInfo);

    /**
     * Common helper function to modify a relation-map based on specified
     * change.
     */
    void UpdateRelation(const ChangeInfo& chgInfo,
            const std::string& relPropName,
            BackLinkMap& backMap);

    /**
     * Appends additional MO objects to 'affSet' that may be affected due
     * to the change in 'obj'.
     */
    void FindOtherAffectedObjects(const ChangeInfo& obj,
            ChangeSet& affSet);

    /**
     * Helper function to find additional objects affected by an object
     * change.
     */
    void FindAffectedObjectsInBackLinkMap(unsigned long ciSeqId,
            const modb::URI& objUri,
            const BackLinkMap& backMap,
            bool recurse,
            ChangeSet& affSet);

    /**
     * Helper function to update an entry in BackLinkMap.
     * Remove 'valueKey' from map[key]. Also remove the entry if
     * map[key] becomes empty
     */
    void RemoveBackLink(BackLinkMap& map, const ObjectKey& key,
            const ObjectKey& valueKey);

    ObjectMap objects;		// map of all objects

    BackLinkMap epgToEp;				// EndpointGroup -> Endpoints
    BackLinkMap networkDomainToEpg;		// NetworkObject -> EndpointGroup
    BackLinkMap networkDomainChildren;	// NetworkObject -> NetworkObject
    BackLinkMap epgCgToPolicy;			// EndpointGroup -> Policy

    ChangeList& changeInfoOut;
    unsigned long changeInfoSeqCounter;
};

}   // namespace enforcer
}   // namespace opflex


#endif // _OPFLEX_ENFORCER_INVENTORY_H_
